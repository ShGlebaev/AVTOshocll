from tkinter import *
from tkinter import messagebox as mb
from tkinter import ttk, filedialog
from tkcalendar import *

import sqlite3 as sq

from io import BytesIO
import os

import PIL
from PIL import ImageTk, Image

import csv
from openpyxl import Workbook
import pandas as pd
import datetime
import re

current_user = None

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS people (
    ID INTEGER,
    Пароль TEXT,
    Фотография BLOB,
    Фамилия TEXT,
    Имя TEXT,
    Отчество TEXT,
    Должность TEXT
    ) """)

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS time (
    Название_экзамена TEXT,
    Дата INTEGER
    ) """)

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS student (
    ID INTEGER,
    Фамилия TEXT,
    Имя TEXT,
    Отчество TEXT,
    Первая_контрольная_точка TEXT, 
    Вторая_контрольная_точка TEXT,
    Третья_контрольная_точка TEXT,
    Четвертая_контрольная_точка TEXT,
    Внутренний_экзамен TEXT,
    Экзамен_в_ГАИ TEXT
    ) """)

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS instructor (
    ID INTEGER,
    Фамилия TEXT,
    Имя TEXT,
    Тип_коробки TEXT,
    Марка_машины TEXT,
    Номер_машины TEXT,
    Тип_топлива TEXT,
    Пробег INTEGER
    ) """)

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS student_hour (
    ID TEXT,
    Фамилия TEXT,
    Имя TEXT,
    Отчество TEXT,
    Количество_часов INTEGER,
    Дата_занятия TEXT
    ) """)

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS student_add (
    Фаммилия TEXT,
    Имя TEXT,
    Номер_телефона TEXT,
    Адрес TEXT
    ) """)

with sq.connect("databaz.db") as db:
    c = db.cursor()
    c.execute(""" CREATE TABLE IF NOT EXISTS theoru_class (
    Дата_занятие TEXT,
    Тема_занятия TEXT
    ) """)


def login_screan(root):
    clear_screen(root)
    Label(root, text="Авторизация").pack()
    Label(root, text="Введите ID:").pack()
    ID_entry = Entry(root)
    ID_entry.pack()
    Label(root, text="Пароль:").pack()
    password_entry = Entry(root, show="*")
    password_entry.pack()
    togle = Button(root, text="Показать", command=lambda: toggle_password(password_entry, togle))
    togle.place(x=265, y=80)
    Button(root, text="Войти", command=lambda: login(root, ID_entry.get(), password_entry.get())).pack()

    root.bind("<b>", lambda event: user_add())


def toggle_password(password_entry, togle):
    if password_entry.cget("show") == "*":
        password_entry.config(show="")
    else:
        password_entry.config(show="*")


def login(root, ID_entry, password_entry):
    global current_user
    if not ID_entry or not password_entry:
        mb.showerror("Ошибка", "Вы не ввели логин или пароль!")
    else:
        with sq.connect("databaz.db") as db:
            c = db.cursor()
            c.execute("SELECT * FROM people WHERE ID=? AND Пароль=?", (ID_entry, password_entry))
            user = c.fetchone()
            if user:
                current_user = {
                    'ID': user[0],
                    'Пароль': user[1],
                    'Фамилия': user[3],
                    'Имя': user[4],
                    'Отчество': user[5],
                    'Должность': determine_user_post(user[0])
                }
                main_screen(root)
                mb.showinfo("Авторизация", "Авторизация прошла успешно")
            else:
                mb.showerror("Ошибка", "Неверный ID или пароль")


def determine_user_post(ID):
    first_digit = int(str(ID)[0])
    if first_digit == 1:
        return "Администратор"
    elif first_digit == 2:
        return "Преподаватель"
    elif first_digit == 3:
        return "Преподаватель-методист"
    elif first_digit == 4:
        return "Студент"
    else:
        return "Неизвестно"


def main_screen(root):
    clear_screen(root)
    if current_user:
        first_digit = int(str(current_user['ID'])[0])
        if first_digit == 1:
            admin_screan(root)
        elif first_digit == 2:
            teacher_screan(root)
        elif first_digit == 3:
            instructor_screan(root)
        elif first_digit == 4:
            student_screan(root)
        else:
            Label(root, text="Неизвестная роль").pack()
    else:
        Label(root, text="Неизвестная роль").pack()


def add_user(id, password, surname, name, patronymic, post, photo_path):
    if id and password and surname and name and patronymic and post and photo_path:
        try:
            with sq.connect("databaz.db") as db:
                c = db.cursor()

                # Загрузка фотографии из файла
                with open(photo_path, 'rb') as file:
                    photo_data = file.read()

                # Вставка данных пользователя в базу данных
                c.execute("INSERT INTO people (ID, Пароль, Фамилия, Имя, Отчество, Должность, Фотография) "
                          "VALUES (?, ?, ?, ?, ?, ?, ?)",
                          (id, password, surname, name, patronymic, post, photo_data))

                mb.showinfo("Успех", "Пользователь успешно добавлен!")
        except Exception as e:
            mb.showerror("Ошибка", f"Произошла ошибка при добавлении пользователя: {str(e)}")
    else:
        mb.showerror("Ошибка", "Все поля должны быть заполнены!")


def user_add():
    second = Toplevel()
    Label(second, text="Добавление пользователя").pack()

    Label(second, text="ID:").pack()
    id_entry = Entry(second)
    id_entry.pack()

    Label(second, text="Пароль:").pack()
    password_entry = Entry(second)
    password_entry.pack()

    Label(second, text="Фамилия:").pack()
    surname_entry = Entry(second)
    surname_entry.pack()

    Label(second, text="Имя:").pack()
    name_entry = Entry(second)
    name_entry.pack()

    Label(second, text="Отчество:").pack()
    patronymic_entry = Entry(second)
    patronymic_entry.pack()

    Label(second, text="Фотография:").pack()
    photo_entry = Entry(second)
    photo_entry.pack()
    photo_btn = Button(second, text="...", command=lambda: select_file(photo_entry))
    photo_btn.place(x=137, y=239)

    Label(second, text="Должность:").pack()
    post_combobox = ttk.Combobox(second, values=["Администратор", "Преподаватель", "Преподаватель-инструктор", "Студент"])
    post_combobox.pack()

    Button(second, text="Добавить", command=lambda: add_user(id_entry.get(), password_entry.get(), surname_entry.get(),
                                                           name_entry.get(),
                                    patronymic_entry.get(), post_combobox.get(), photo_entry.get())).pack()


def select_file(photo_entry):
    file_path = filedialog.askopenfilename()

    photo_entry.delete(0, 'end')
    photo_entry.insert(0, file_path)


def show_users():
    users_window = Toplevel()
    users_window.geometry('400x250')  # Задаем меньший размер окна

    # Создаем Treeview с настройкой ширины столбцов
    users_tree = ttk.Treeview(users_window, columns=("ID", "Фамилия", "Имя"), show='headings')
    users_tree.column("ID", width=50)  # Задаем ширину столбца
    users_tree.column("Фамилия", width=150)
    users_tree.column("Имя", width=150)
    users_tree.heading("ID", text="ID")
    users_tree.heading("Фамилия", text="Фамилия")
    users_tree.heading("Имя", text="Имя")

    # Заполняем данными
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT * FROM people")
        users = c.fetchall()
        for user in users:
            users_tree.insert("", "end", values=(user[0], user[3], user[4]))

    users_tree.pack()  # Позволяем этому виджету заполнить все доступное пространство

    # Функция для удаления выбранного пользователя
    def delete_selected_user():
        selected_item = users_tree.selection()[0]  # Получаем выбранный элемент
        user_details = users_tree.item(selected_item)['values']  # Получаем детали пользователя
        user_id = user_details[0]  # Получаем ID пользователя

        # Создаем окно подтверждения
        confirm_window = Toplevel(users_window)
        confirm_window.title("Подтверждение удаления")
        confirm_window.geometry("300x150")

        Label(confirm_window, text=f"Вы точно хотите удалить следующую запись?\nID: {user_id}\nФамилия: {user_details[1]}\nИмя: {user_details[2]}").pack(pady=10)

        def confirm_delete():
            users_tree.delete(selected_item)  # Удаляем элемент из Treeview
            with sq.connect("databaz.db") as db:  # Удаляем пользователя из базы данных
                c = db.cursor()
                c.execute("DELETE FROM people WHERE ID=?", (user_id,))
                db.commit()
            confirm_window.destroy()

        Button(confirm_window, text="Удалить", command=confirm_delete).pack(side=LEFT, padx=20, pady=10)
        Button(confirm_window, text="Отмена", command=confirm_window.destroy).pack(side=RIGHT, padx=20, pady=10)

    delete_button = Button(users_window, text="Удалить", command=delete_selected_user)
    delete_button.pack()


def admin_screan(root):
    print(current_user)
    clear_screen(root)
    root.title("Меню администратора")
    Label(root, text="Профиль администратора").pack()
    #Приветстиве
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT Фамилия, Имя, Отчество, Фотография FROM people WHERE ID = ?",
                  (current_user['ID'],))
        user_info = c.fetchone()

    full_name = f"{user_info[0]} {user_info[1]} {user_info[2]}"

    try:
        photo = Image.open(BytesIO(user_info[3]))
    except PIL.UnidentifiedImageError:
        print("Unable to open image")
        photo = None

    Label(root, text=f"Добро пожаловать, {full_name}!").pack()

    if photo is not None:
        photo_frame = Frame(root)
        photo_frame.pack()
        photo_label = Label(photo_frame)
        photo_label.pack()
        photo_image = ImageTk.PhotoImage(photo)
        photo_label.config(image=photo_image)
        photo_label.image = photo_image
    #Приветстиве
    menu_admin = Menu(root)
    root.config(menu=menu_admin)
    submenu_admin = Menu(menu_admin, tearoff=0)
    menu_admin.add_cascade(label='Управление пользователями', menu=submenu_admin)
    submenu_admin.add_command(label='Добавить пользователя', command=user_add)
    submenu_admin.add_command(label='Удалить пользователя', command=show_users)
    submenu_admin.add_command(label='Просмотр пользователей', command=view_user)
    submenu_admin.add_command(label='Просмотр автомобилей', command=viewing_cars)
    menu_admin.add_command(label='Календарь', command=open_calendar)
    menu_admin.add_command(label='Памятка', command=the_memo)

    # Добавляем кнопку выхода из аккаунта
    logout_button = Button(root, text="Выйти", command=lambda: logout(root))
    logout_button.place(relx=1.0, rely=0.0, anchor='ne')


def viewing_cars():
    view_car = Toplevel()
    view_car.title('Просмотр машин')

    # Настройка Treeview
    tree = ttk.Treeview(view_car, columns=('ID', 'Фамилия', 'Имя', 'Тип_коробки', 'Марка_машины', 'Номер_машины', 'Тип_топлива', 'Пробег'), show='headings')
    tree.heading('ID', text='ID')
    tree.heading('Фамилия', text='Фамилия')
    tree.heading('Имя', text='Имя')
    tree.heading('Тип_коробки', text='Тип коробки')
    tree.heading('Марка_машины', text='Марка машины')
    tree.heading('Номер_машины', text='Номер машины')
    tree.heading('Тип_топлива', text='Тип топлива')
    tree.heading('Пробег', text='Пробег')
    tree.column('ID', width=50)
    tree.column('Фамилия', width=100)
    tree.column('Имя', width=100)
    tree.column('Тип_коробки', width=120)
    tree.column('Марка_машины', width=120)
    tree.column('Номер_машины', width=120)
    tree.column('Тип_топлива', width=100)
    tree.column('Пробег', width=100)
    tree.pack(fill='both', expand=True)

    # Подключение к базе данных и выборка данных
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT * FROM instructor")
        for row in c.fetchall():
            tree.insert('', 'end', values=row)


def view_user():
    v_user = Toplevel()
    v_user.title('Просмотр всех пользователей')

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT ID, Фотография, Фамилия, Имя, Отчество, Должность FROM people")
        selected_rows = c.fetchall()  # Получаем все выбранные строки

    view_tree = ttk.Treeview(v_user, columns=("ID", "Фотография", "Фамилия", "Имя", "Отчество", "Должность"), show='headings')

    # Настройка столбцов и заголовков Treeview
    view_tree.column("#1", width=35, stretch=False)
    view_tree.heading("#1", text="ID")
    view_tree.column("#2", width=120)
    view_tree.heading("#2", text="Фотография")
    view_tree.column("#3", width=95)
    view_tree.heading("#3", text="Фамилия")
    view_tree.column("#4", width=95)
    view_tree.heading("#4", text="Имя")
    view_tree.column("#5", width=95)
    view_tree.heading("#5", text="Отчество")
    view_tree.column("#6", width=160)  # Ширина столбца для изображения
    view_tree.heading("#6", text="Должность")

    for row in selected_rows:
        # Загрузка изображения из файла
        image_path = row[1]  # Путь к файлу изображения
        if os.path.exists(image_path):
            image = Image.open(image_path)
            # Изменение размера изображения, если необходимо
            image = image.resize((80, 80))  # Измените размер по вашему усмотрению
            # Преобразование изображения в формат, понятный Tkinter
            image_tk = ImageTk.PhotoImage(image)
            # Вставка изображения в Treeview
            view_tree.insert("", "end", values=(row[0], image_tk, row[2], row[3], row[4], row[5]))
        else:
            # Если файл изображения не найден, вставляем пустое значение
            view_tree.insert("", "end", values=(row[0], "", row[2], row[3], row[4], row[5]))

    view_tree.pack()

    Button(v_user, text="Фильтр", command=lambda: open_filter_window(view_tree, selected_rows)).pack()


def open_filter_window(view_tree, selected_rows):
    filter_window = Toplevel()
    filter_window.geometry('310x180')
    filter_window.title('Настраиваемый фильтр')

    filter_label = Label(filter_window, text="Выберите критерии фильтрации:")
    filter_label.pack()

    # Dropdown for selecting the first digit of ID
    id_label = Label(filter_window, text="Первая цифра ID:")
    id_label.pack()
    id_options = ["1", "2", "3", "4"]
    id_var = StringVar()
    id_dropdown = ttk.Combobox(filter_window, textvariable=id_var, values=id_options)
    id_dropdown.pack()

    # Entry for specifying last name
    last_name_label = Label(filter_window, text="Фамилия:")
    last_name_entry = Entry(filter_window)
    last_name_label.pack()
    last_name_entry.pack()

    # Entry for specifying first name
    first_name_label = Label(filter_window, text="Имя:")
    first_name_entry = Entry(filter_window)
    first_name_label.pack()
    first_name_entry.pack()

    apply_filter_button = Button(filter_window, text="Применить фильтр", command=lambda: apply_filter(view_tree, selected_rows, id_var.get(), last_name_entry.get(), first_name_entry.get()))
    apply_filter_button.pack()
    Button(filter_window, text="Экспортировать данные", command=lambda: complete(view_tree)).pack()


def complete(view_tree):
    export_window = Toplevel()
    export_window.geometry('300x300')
    export_window.title('Экспорт данных')

    # Создание и упаковка Label и Combobox для выбора формата экспорта
    Label(export_window, text="Выберите формат файла:").pack(pady=10)
    format_var = StringVar()
    format_dropdown = ttk.Combobox(export_window, textvariable=format_var, values=["TXT", "Excel"])
    format_dropdown.pack()

    # Поле для выбора директории
    Label(export_window, text="Выберите директорию:").pack(pady=10)
    directory_var = StringVar()
    directory_entry = ttk.Entry(export_window, textvariable=directory_var, width=30)
    directory_entry.pack()
    Button(export_window, text="Выбрать директорию", command=lambda: select_directory(directory_var)).pack(pady=5)

    # Поле для ввода имени файла
    Label(export_window, text="Введите имя файла:").pack(pady=10)
    filename_var = StringVar()
    filename_entry = ttk.Entry(export_window, textvariable=filename_var, width=30)
    filename_entry.pack()

    # Кнопка для запуска экспорта
    Button(export_window, text="Экспортировать", command=lambda: export_data(view_tree, format_var.get(), directory_var.get(), filename_var.get())).pack(pady=10)


def select_directory(directory_var):
    directory = filedialog.askdirectory()
    directory_var.set(directory)


def export_data(view_tree, format_choice, directory, filename):
    # Собираем данные из Treeview
    data = [(view_tree.item(item, "values")) for item in view_tree.get_children()]

    # Полный путь к файлу
    filepath = f"{directory}/{filename}"

    # Выбор формата экспорта
    if format_choice == 'TXT':
        with open(f'{filepath}.txt', 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f, delimiter='\t')
            writer.writerow(['ID', 'Фотография', 'Фамилия', 'Имя', 'Отчество', 'Должность'])
            for row in data:
                writer.writerow(row)
    elif format_choice == 'Excel':
        wb = Workbook()
        ws = wb.active
        ws.append(['ID', 'Фотография', 'Фамилия', 'Имя', 'Отчество', 'Должность'])
        for row in data:
            ws.append(row)
        wb.save(f'{filepath}.xlsx')

    print("Данные экспортированы в формате:", format_choice)


def apply_filter(view_tree, selected_rows, id_filter, last_name_filter, first_name_filter):
    # Clear the existing data in the Treeview
    for item in view_tree.get_children():
        view_tree.delete(item)

    # Apply the filters and insert the filtered rows into the Treeview
    for row in selected_rows:
        if ((id_filter == '' or str(row[0]).startswith(id_filter)) and
                (last_name_filter == '' or row[2].strip().casefold() == last_name_filter.strip().casefold()) and
                (first_name_filter == '' or row[3].strip().casefold() == first_name_filter.strip().casefold())):
            # Остальной код

            image_path = row[1]  # Путь к файлу изображения
            if os.path.exists(image_path):
                image = Image.open(image_path)
                image = image.resize((80, 80))  # Измените размер по вашему усмотрению
                image_tk = ImageTk.PhotoImage(image)
                view_tree.insert("", "end", values=(row[0], image_tk, row[2], row[3], row[4], row[5]))
            else:
                view_tree.insert("", "end", values=(row[0], "", row[2], row[3], row[4], row[5]))


def open_calendar():
    calendar_window = Toplevel()
    calendar_window.title("Календарь")

    cal = Calendar(calendar_window, selectmode='day', locale='ru_RU')
    cal.pack()

    event_text = Text(calendar_window, height=10, width=40)
    event_text.pack()

    Button(calendar_window, text="Назначить экзамен", command=lambda: open_event_window(event_text)).pack()
    Button(calendar_window, text="Обновить", command=lambda: display(event_text)).pack()


def the_memo(file_path='Meno.txt'):
    meno_scrin = Toplevel()
    meno_scrin.title("Памятка")
    Label(meno_scrin, text="Памятка по добовлению пользователей").pack()
    try:
        with open(file_path, "r", encoding='utf-8') as file:
            text = file.read()
        text_field = Text(meno_scrin)
        text_field.insert('1.0', text)
        text_field.configure(state='disabled')
        text_field.pack()
    except IOError as e:
        print(f"Ошибка при чтении файла: {e}")


def back():
    clear_screen(root)
    admin_screan(root)


def open_event_window(event_type):
    event_window = Toplevel()
    event_window.title(event_type)

    Label(event_window, text="Год:").pack()
    year_entry = Entry(event_window)
    year_entry.pack()

    Label(event_window, text="Месяц:").pack()
    month_entry = Entry(event_window)
    month_entry.pack()

    Label(event_window, text="День:").pack()
    day_entry = Entry(event_window)
    day_entry.pack()

    Label(event_window, text="Час:").pack()
    hour_entry = Entry(event_window)
    hour_entry.pack()

    Label(event_window, text="Минуты:").pack()
    minutes_entry = Entry(event_window)
    minutes_entry.pack()

    Label(event_window, text="Тип экзамена:").pack()
    nameex_combobox = ttk.Combobox(event_window, values=[
        "1. Первая контрольная точка",
        "2. Вторая контрольная точка",
        "3. Третья контрольная точка",
        "4. Четвретая контрольная точка",
        "5. Внутренний экзамен",
        "6. Экзамен в ГАИ"
    ])
    nameex_combobox.pack()

    def add_date():
        year = year_entry.get()
        month = month_entry.get()
        day = day_entry.get()
        hour = hour_entry.get()
        minutes = minutes_entry.get()
        nameex = nameex_combobox.get()

        if not year or not month or not day or not hour or not minutes or not nameex:
            mb.showerror("Ошибка", "Пожалуйста, заполните все поля.")
            return

        if int(month) > 12 or int(day) > 31 or int(hour) > 23 or int(minutes) > 59:
            mb.showerror("Ошибка", "Проверьте вводимые данные, а конкретно, 'месяц', 'день', 'часы' и 'минуты'.")
            return

        try:
            exam_date = datetime.datetime(int(year), int(month), int(day), int(hour), int(minutes))
        except ValueError as e:
            mb.showerror("Ошибка", f"Некорректная дата или время: {e}")
            return

        current_date = datetime.datetime.now()

        if exam_date < current_date:
            mb.showerror("Ошибка", "Экзамен не может быть назначен на прошедшую дату.")
            return

        with sq.connect("databaz.db") as db:
            c = db.cursor()
            try:
                c.execute("INSERT INTO time (Название_экзамена, Дата) VALUES (?, ?)",
                          (nameex, exam_date.strftime('%Y%m%d%H%M')))
                db.commit()
                mb.showinfo("Успех", "Данные успешно добавлены.")
                display(event_text)
            except sq.Error as e:
                mb.showerror("Ошибка", f"Произошла ошибка при добавлении данных: {e}")

    Button(event_window, text="Добавить", command=add_date).pack()


def display(event_text):
    event_text.delete(1.0, END)

    # Извлечение данных из базы данных
    conn = sq.connect("databaz.db")
    c = conn.cursor()
    c.execute("SELECT Название_экзамена, Дата FROM time")
    rows = c.fetchall()
    for row in rows:
        name_ex = row[0]
        date = str(row[1])

        # Форматирование даты и времени
        year = date[:4]
        month = date[4:6]
        day = date[6:8]
        hour = date[8:10]
        minutes = date[10:12]

        formatted_date = f"{day}.{month}.{year} {hour}:{minutes}"

        # Добавление данных в текстовое поле
        event_text.insert(END, f"{formatted_date}: {name_ex}\n")


def teacher_screan(root):
    clear_screen(root)
    Label(root, text="Профиль преподавателя").pack()

    # Приветстиве
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT Фамилия, Имя, Отчество, Фотография FROM people WHERE ID = ?", (current_user['ID'],))
        user_info = c.fetchone()

    full_name = f"{user_info[0]} {user_info[1]} {user_info[2]}"

    try:
        photo = Image.open(BytesIO(user_info[3]))
    except PIL.UnidentifiedImageError:
        print("Unable to open image")
        photo = None

    Label(root, text=f"Добро пожаловать, {full_name}!").pack()

    if photo is not None:
        photo_frame = Frame(root, width=2, height=2)
        photo_frame.pack()
        photo_label = Label(photo_frame)
        photo_label.pack()
        photo_image = ImageTk.PhotoImage(photo)
        photo_label.config(image=photo_image)
        photo_label.image = photo_image
    #Приветстиве
    menu_teacher = Menu(root)
    root.config(menu=menu_teacher)
    submenu_teacher = Menu(menu_teacher, tearoff=0)
    menu_teacher.add_cascade(label='Действия с учениками', menu=submenu_teacher)
    submenu_teacher.add_command(label='Просмотр учеников', command=view)
    submenu_teacher.add_command(label='Назначить теоретическое занятие', command=class_theory)
    menu_teacher.add_command(label='Календарь', command=open_calendar)
    menu_teacher.add_command(label='Памятка', command=the_memo)

    logout_button = Button(root, text="Выйти", command=lambda: logout(root))
    logout_button.place(relx=1.0, rely=0.0, anchor='ne')


def class_theory():
    add_theory = Toplevel()
    add_theory.title('Теоретическое занятие')

    # Entry for the date of the class
    Label(add_theory, text="Дата занятия (dd-mm-yyyy):").pack()
    date_entry = Entry(add_theory)
    date_entry.pack()

    # Entry for the topic of the class
    Label(add_theory, text="Тема занятия:").pack()
    topic_entry = Entry(add_theory)
    topic_entry.pack()

    def class_add():
        date = date_entry.get()
        topic = topic_entry.get()

        # Validate the date format
        if not re.match(r'^\d{2}-\d{2}-\d{4}$', date):
            mb.showerror("Ошибка", "Неверный формат даты. Используйте dd-mm-yyyy.")
            return

        day, month, year = map(int, date.split('-'))
        if day > 31 or month > 12:
            mb.showerror("Ошибка", "Неверная дата. День не может быть больше 31, и месяц не может быть больше 12.")
            return

        entered_date = datetime.datetime(year, month, day)
        # Get the current date
        current_date = datetime.datetime.now()

        if entered_date < current_date:
            mb.showerror("Ошибка", "Нельзя назначить занятие на прошедшую дату.")
            return

        with sq.connect("databaz.db") as db:
            c = db.cursor()
            try:
                c.execute("INSERT INTO theoru_class (Дата_занятие, Тема_занятия) VALUES (?, ?)", (date, topic))
                db.commit()
                mb.showinfo("Успех", "Занятие добавлено.")
            except sq.Error as e:
                mb.showerror("Ошибка", f"Произошла ошибка при добавлении занятия: {e}")

    Button(add_theory, text="Добавить занятие", command=class_add).pack()


def selection_from_database_and_update_tree():
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT ID, Фамилия, Имя, Отчество FROM people WHERE ID LIKE '4%'")
        selected_rows = c.fetchall()

        c.execute("SELECT COUNT(*) FROM student")
        result = c.fetchone()
        if result[0] == 0:
            for row in selected_rows:
                c.execute("""
                    INSERT INTO student (ID, Фамилия, Имя, Отчество, Первая_контрольная_точка, Вторая_контрольная_точка, 
                    Третья_контрольная_точка, Четвертая_контрольная_точка, Внутренний_экзамен, Экзамен_в_ГАИ)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    row[0], row[1], row[2], row[3], "Не сдал", "Не сдал", "Не сдал", "Не сдал", "Не сдал", "Не сдал"
                ))

        db.commit()

    update_tree()


def create_view_window():
    global view_top, user_tree
    view_top = Toplevel()
    view_top.title("Просмотр")
    view_top.geometry('1410x400')

    user_tree = ttk.Treeview(view_top, columns=("ID", "Фамилия", "Имя", "Отчество", "Первая контрольная точка",
                                                "Вторая контрольная точка", "Третья контрольная точка",
                                                "Четвертая контрольная точка", "Внутренний экзамен", "Экзамен в ГАИ"),
                             show='headings')
    user_tree.column("#1", width=35, stretch=False)
    user_tree.heading("#1", text="ID")
    user_tree.column("#2", width=90)
    user_tree.heading("#2", text="Фамилия")
    user_tree.column("#3", width=90)
    user_tree.heading("#3", text="Имя")
    user_tree.column("#4", width=90)
    user_tree.heading("#4", text="Отчество")
    user_tree.column("#5", width=200)
    user_tree.heading("#5", text="Первая контрольная точка")
    user_tree.column("#6", width=200)
    user_tree.heading("#6", text="Вторая контрольная точка")
    user_tree.column("#7", width=200)
    user_tree.heading("#7", text="Третья контрольная точка")
    user_tree.column("#8", width=200)
    user_tree.heading("#8", text="Четвертая контрольная точка")
    user_tree.column("#9", width=150)
    user_tree.heading("#9", text="Внутренний экзамен")
    user_tree.column("#10", width=150)
    user_tree.heading("#10", text="Экзамен в ГАИ")
    user_tree.pack()

    Button(view_top, text="Выбрать", command=lambda: marking_points(user_tree, view_top)).pack()
    Button(view_top, text="Экспортировать данные", command=lambda: complete(user_tree)).pack(pady=10)


def update_tree():
    for item in user_tree.get_children():
        user_tree.delete(item)

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT * FROM student")
        rows = c.fetchall()

        for row in rows:
            user_tree.insert("", "end", values=row)


def select_directory(directory_var):
    directory = filedialog.askdirectory()
    directory_var.set(directory)


def export_data(tree, format_type, directory, filename):
    # Собираем данные из Treeview
    data = [tree.item(row)['values'] for row in tree.get_children()]
    df = pd.DataFrame(data, columns=[col for col in tree['columns']])

    # Экспорт данных
    if format_type == "TXT":
        filepath = f"{directory}/{filename}.txt"
        df.to_csv(filepath, index=False, sep='\t')
    elif format_type == "Excel":
        filepath = f"{directory}/{filename}.xlsx"
        df.to_excel(filepath, index=False)


def complete(view_tree):
    export_window = Toplevel()
    export_window.geometry('300x300')
    export_window.title('Экспорт данных')

    Label(export_window, text="Выберите формат файла:").pack(pady=10)
    format_var = StringVar()
    format_dropdown = ttk.Combobox(export_window, textvariable=format_var, values=["TXT", "Excel"])
    format_dropdown.pack()

    Label(export_window, text="Выберите директорию:").pack(pady=10)
    directory_var = StringVar()
    directory_entry = ttk.Entry(export_window, textvariable=directory_var, width=30)
    directory_entry.pack()
    Button(export_window, text="Выбрать директорию", command=lambda: select_directory(directory_var)).pack(pady=5)

    Label(export_window, text="Введите имя файла:").pack(pady=10)
    filename_var = StringVar()
    filename_entry = ttk.Entry(export_window, textvariable=filename_var, width=30)
    filename_entry.pack()

    Button(export_window, text="Экспортировать",
           command=lambda: export_data(view_tree, format_var.get(), directory_var.get(), filename_var.get())).pack(
        pady=10)


def update_tree():
    # Очистка текущих данных в дереве
    for item in user_tree.get_children():
        user_tree.delete(item)

    # Загрузка новых данных в дерево
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT * FROM student")
        rows = c.fetchall()

        for row in rows:
            user_tree.insert("", "end", values=row)


def marking_points(user_tree, view_top):
    selected_item = user_tree.selection()[0]  # Получаем выбранный элемент
    user_details = user_tree.item(selected_item)['values']  # Получаем детали пользователя
    user_id = user_details[0]  # Получаем ID пользователя
    user_name = f'{user_details[1]} {user_details[2]}'

    add_mark = Toplevel()
    add_mark.title('Отметка')
    add_mark.geometry('320x200')

    Label(add_mark, text=f"Выбран ученик {user_name}").pack()
    lbl1 = Label(add_mark, text="Первая контрольная точка")
    lbl1.place(x=0, y=20)
    combo1 = ttk.Combobox(add_mark)
    combo1.place(x=168, y=20)
    combo1['values'] = ('Сдал', 'Не сдал')
    lbl2 = Label(add_mark, text="Вторая контрольная точка")
    lbl2.place(x=0, y=40)
    combo2 = ttk.Combobox(add_mark)
    combo2.place(x=168, y=40)
    combo2['values'] = ('Сдал', 'Не сдал')
    lbl3 = Label(add_mark, text="Третья контрольная точка")
    lbl3.place(x=0, y=60)
    combo3 = ttk.Combobox(add_mark)
    combo3.place(x=168, y=60)
    combo3['values'] = ('Сдал', 'Не сдал')
    lbl4 = Label(add_mark, text="Четвертая контрольная точка")
    lbl4.place(x=0, y=80)
    combo4 = ttk.Combobox(add_mark)
    combo4.place(x=168, y=80)
    combo4['values'] = ('Сдал', 'Не сдал')
    lbl5 = Label(add_mark, text="Внутренний экзамен")
    lbl5.place(x=0, y=100)
    combo5 = ttk.Combobox(add_mark)
    combo5.place(x=168, y=100)
    combo5['values'] = ('Сдал', 'Не сдал')
    lbl6 = Label(add_mark, text="Экзамен в ГАИ")
    lbl6.place(x=0, y=120)
    combo6 = ttk.Combobox(add_mark)
    combo6.place(x=168, y=120)
    combo6['values'] = ('Сдал', 'Не сдал')

    def insert_and_update_students():
        with sq.connect("databaz.db") as db:
            c = db.cursor()
            c.execute("""
                UPDATE student
                SET 
                    Первая_контрольная_точка = ?,
                    Вторая_контрольная_точка = ?,
                    Третья_контрольная_точка = ?,
                    Четвертая_контрольная_точка = ?,
                    Внутренний_экзамен = ?,
                    Экзамен_в_ГАИ = ?
                WHERE ID = ?
            """, (
                combo1.get(),
                combo2.get(),
                combo3.get(),
                combo4.get(),
                combo5.get(),
                combo6.get(),
                user_id
            ))

            db.commit()

        update_tree()

    Button(add_mark, text="Добавить и обновить", command=insert_and_update_students).place(x=125, y=170)


def view():
    create_view_window()
    selection_from_database_and_update_tree()


tree_instructor = None


def instructor_screan(root):
    global tree_instructor
    clear_screen(root)

    Label(root, text="Профиль преподавателя-инструктора").pack()

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT Фамилия, Имя, Отчество, Фотография FROM people WHERE ID = ?",
                  (current_user['ID'],))
        user_info = c.fetchone()

    full_name = f"{user_info[0]} {user_info[1]} {user_info[2]}"

    try:
        photo = Image.open(BytesIO(user_info[3]))
    except Exception as e:
        print(f"Unable to open image: {e}")
        photo = None

    Label(root, text=f"Добро пожаловать, {full_name}!").pack()

    if photo:
        photo_image = ImageTk.PhotoImage(photo)
        photo_label = Label(root, image=photo_image)
        photo_label.image = photo_image
        photo_label.pack()

    menu_instructor = Menu(root)
    root.config(menu=menu_instructor)
    menu_instructor.add_command(label='Просмотр свободных учеников', command=lambda: students_choice())
    menu_instructor.add_command(label='Добавить автомобиль', command=tree_car)
    menu_instructor.add_command(label='Памятка', command=lambda: the_memo())
    menu_instructor.add_command(label='Просмотр данных учеников', command=viewing_data)

    logout_button = Button(root, text="Выйти", command=lambda: logout(root))
    logout_button.place(relx=1.0, rely=0.0, anchor='ne')


def viewing_data():
    view_us = Toplevel()
    view_us.title('Просмтр пользовталей')

    # Создание tree
    tree = ttk.Treeview(view_us,  show='headings')
    tree['columns'] = ('column1', 'column2', 'column3', 'column4')  # Замените на реальные названия столбцов

    # Установка заголовков столбцов
    tree.heading('#0', text='Номер')
    tree.heading('column1', text='Фамилия')
    tree.heading('column2', text='Имя')
    tree.heading('column3', text='Номер телефона')
    tree.heading('column4', text='Адрес')

    # Получение данных из базы данных
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT rowid, Фаммилия, Имя, Номер_телефона, Адрес FROM student_add")
        data = c.fetchall()

    # Вставка данных в tree
    for record in data:
        tree.insert('', 'end', text=record[0], values=(record[1], record[2], record[3], record[4]))

    # Отображение tree
    tree.pack()


def students_choice():
    global stud_tree
    stud_choice = Toplevel()
    stud_choice.geometry('580x260')
    stud_choice.title('Выбор студента')
    stud_tree = ttk.Treeview(stud_choice, columns=("ID", "Фамилия", "Имя", "Отчество", "Количество часов", "Дата занятия"),
                             show='headings')
    stud_tree.column("#1", width=35, stretch=False)
    stud_tree.heading("#1", text="ID")
    stud_tree.column("#2", width=90)
    stud_tree.heading("#2", text="Фамилия")
    stud_tree.column("#3", width=90)
    stud_tree.heading("#3", text="Имя")
    stud_tree.column("#4", width=90)
    stud_tree.heading("#4", text="Отчество")
    stud_tree.column("#5", width=120)
    stud_tree.heading("#5", text="Количество часов")
    stud_tree.column("#6", width=120)
    stud_tree.heading("#6", text="Дата занятия")
    stud_tree.pack()

    Button(stud_choice, text="Выбрать", command=selected_student).pack()
    uppend_tree_stud()


def uppend_tree_stud():
    try:
        with sq.connect("databaz.db") as db:
            c = db.cursor()

            # Выборка студентов из таблицы people, ID которых начинаются на 4
            c.execute("SELECT ID, Фамилия, Имя, Отчество FROM people WHERE ID LIKE '4%'")
            students = c.fetchall()

            # Вставка данных в таблицу student_hour, если их там еще нет
            for student in students:
                c.execute("""
                    INSERT INTO student_hour (ID, Фамилия, Имя, Отчество, Количество_часов, Дата_занятия)
                    SELECT ?, ?, ?, ?, 0, NULL
                    WHERE NOT EXISTS (SELECT 1 FROM student_hour WHERE ID = ?)
                """, (student[0], student[1], student[2], student[3], student[0]))

            db.commit()

            # Обновление данных в таблице student_hour
            c.execute("UPDATE student_hour SET Дата_занятия = NULL, Количество_часов = 60")
            db.commit()

            # Очистка текущих данных в treeview
            stud_tree.delete(*stud_tree.get_children())

            # Выборка обновленных данных из таблицы student_hour
            c.execute("SELECT ID, Фамилия, Имя, Отчество, Количество_часов, Дата_занятия FROM student_hour")
            rows = c.fetchall()

            # Вставка данных в treeview
            for row in rows:
                stud_tree.insert("", "end", values=row)

        print("Treeview обновлен.")
    except Exception as e:
        print(f"Ошибка: {e}")


def selected_student():
    selected_stud = Toplevel()
    selected_stud.title("Назначение практического занятия")

    # Проверяем, выбран ли элемент в Treeview
    selected_items = stud_tree.selection()
    if not selected_items:  # Если ничего не выбрано
        mb.showerror("Ошибка", "Не выбран студент")
        return

    selected_item = selected_items[0]  # Получаем выбранный элемент в Treeview
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        # Получаем ID выбранного студента
        selected_id = stud_tree.item(selected_item, 'values')[0]
        c.execute("SELECT Фамилия, Имя, Отчество FROM student_hour WHERE ID = ?", (selected_id,))
        user_info = c.fetchone()

    if user_info is None:
        mb.showerror("Ошибка", "Информация о студенте не найдена")
        return

    full_name = f"{user_info[0]} {user_info[1]} {user_info[2]}"
    Label(selected_stud, text=f"Выбран студент: {full_name}").pack()
    Label(selected_stud, text="Выбирите занятие.").pack()
    class_combox = ttk.Combobox(selected_stud)
    class_combox['values'] = ('Короткое занятие(1 час)', 'Длиное занятие(2 часа)')
    class_combox.pack()
    Label(selected_stud, text="Введите дату занятия(в формате 'дд-мм-гггг'").pack()
    date_entry = Entry(selected_stud)
    date_entry.pack()
    Button(selected_stud, text="Назначить",
           command=lambda: add_class(class_combox, date_entry, selected_id, full_name)).pack()


def add_class(class_combox, date_entry, user_id, full_name):
    date_str = date_entry.get()

    # Проверка корректности формата даты
    try:
        date = datetime.datetime.strptime(date_str, '%d-%m-%Y')
        # Проверка, что дата не превышает 31 день и 12 месяцев
        if date.day > 31 or date.month > 12:
            mb.showerror("Ошибка", "Некорректная дата. День не может быть больше 31, и месяц не может быть больше 12.")
            return
        # Проверка, что дата не назначена на прошедшее число
        if date < datetime.datetime.now():
            mb.showerror("Ошибка", "Вы не можете назначить занятие на прошедшую дату.")
            return
    except ValueError:
        mb.showerror("Ошибка", "Некорректный формат даты")
        return

    class_type = class_combox.get()
    hours = -1 if class_type == "Короткое занятие(1 час)" else -2

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("UPDATE student_hour SET Количество_часов = Количество_часов + ?, Дата_занятия = ? WHERE ID = ?",
                  (hours, date.strftime('%d-%m-%Y'), user_id))
        db.commit()

    mb.showinfo("Успешно", "Занятие назначено.")
    print(f"Занятие назначено для {full_name} на {date.strftime('%d-%m-%Y')}. Часы изменены на {hours}.")


def tree_car():
    global tree_instructor
    tree_cars = Toplevel()
    tree_cars.geometry('670x260')
    tree_instructor = ttk.Treeview(tree_cars, columns=("ID", "Фамилия", "Имя", "Тип коробки", "Марка машины",
                                                       "Номер машины", "Тип топлива", "Пробег"), show='headings')
    tree_instructor.column("#1", width=35, stretch=False)
    tree_instructor.heading("#1", text="ID")
    tree_instructor.column("#2", width=90)
    tree_instructor.heading("#2", text="Фамилия")
    tree_instructor.column("#3", width=70)
    tree_instructor.heading("#3", text="Имя")
    tree_instructor.column("#4", width=90)
    tree_instructor.heading("#4", text="Тип коробки")
    tree_instructor.column("#5", width=100)
    tree_instructor.heading("#5", text="Марка машины")
    tree_instructor.column("#6", width=100)
    tree_instructor.heading("#6", text="Тип топлива")
    tree_instructor.column("#7", width=90)
    tree_instructor.heading("#7", text="Номер машины")
    tree_instructor.column("#8", width=80)
    tree_instructor.heading("#8", text="Пробег")
    tree_instructor.pack()

    # Загружаем данные только для текущего пользователя
    update_tree_instructor()

    Button(tree_cars, text="Добавить свой автомобиль", command=add_carr).pack()


def add_carr():
    cars_add = Toplevel()
    cars_add.geometry('300x250')
    cars_add.title('Добавка автомобиля')

    Label(cars_add, text="Введите марку машины:").pack()
    stamp_entry = Entry(cars_add)
    stamp_entry.pack()
    Label(cars_add, text="Введите тип коробки(механика/автомат):").pack()
    car_combox = ttk.Combobox(cars_add)
    car_combox['values'] = ('Механика', 'Автомат')
    car_combox.pack()
    Label(cars_add, text="Тип топлива:").pack()
    fuel_entry = Entry(cars_add)
    fuel_entry.pack()
    Label(cars_add, text="Введите гос.номер автомобиля:").pack()
    number_entry = Entry(cars_add)
    number_entry.pack()
    Label(cars_add, text="Введите пробег:").pack()
    mileage_entry = Entry(cars_add)
    mileage_entry.pack()
    Button(cars_add, text="Добавить",
           command=lambda: add_car(stamp_entry.get(), car_combox.get(), fuel_entry.get(), number_entry.get(),
                                   mileage_entry.get())).pack()


def add_car(stamp_entry, car_combox, fuel_entry, number_entry, mileage_entry):
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        # Добавляем запись с введенными значениями
        c.execute("INSERT INTO instructor (Фамилия, Имя, Марка_машины, Тип_коробки, Тип_топлива, "
                  "Номер_машины, Пробег, ID) "
                  "VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                  (current_user["Фамилия"], current_user["Имя"], stamp_entry, car_combox, fuel_entry,
                   number_entry, mileage_entry, current_user["ID"]))
        db.commit()

    mb.showinfo("Успех!", "Автомобиль успешно добавлен!")

    # Обновить Treeview
    update_tree_instructor()


def update_tree_instructor():
    global tree_instructor
    if tree_instructor is not None:
        tree_instructor.delete(*tree_instructor.get_children())
        with sq.connect("databaz.db") as db:
            c = db.cursor()
            c.execute(
                "SELECT ID, Фамилия, Имя, Марка_машины, Тип_коробки, Тип_топлива, Номер_машины, Пробег FROM "
                "instructor WHERE ID = ?",
                (current_user["ID"],))
            rows = c.fetchall()
            for row in rows:
                tree_instructor.insert("", END, values=row)


def student_screan(root):
    clear_screen(root)
    Label(root, text="Профиль студента").pack()

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT ID, Фамилия, Имя, Отчество, Фотография FROM people WHERE ID = ?", (current_user['ID'],))
        user_info = c.fetchone()

    full_name = f"{user_info[1]} {user_info[2]} {user_info[3]}"

    try:
        photo = Image.open(BytesIO(user_info[4]))
    except PIL.UnidentifiedImageError:
        print("Unable to open image")
        photo = None

    Label(root, text=f"Добро пожаловать, {full_name}!").pack()

    if photo is not None:
        photo_frame = Frame(root, width=5, height=5)
        photo_frame.pack()
        photo_label = Label(photo_frame)
        photo_label.pack()
        photo_image = ImageTk.PhotoImage(photo)
        photo_label.config(image=photo_image)
        photo_label.image = photo_image

    # Добавляем кнопку выхода из аккаунта
    logout_button = Button(root, text="Выйти", command=lambda: logout(root))
    logout_button.place(relx=1.0, rely=0.0, anchor='ne')

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT ID FROM people WHERE ID LIKE '4%'")
        selected_student_id = c.fetchone()[0]  # Получаем ID из таблицы people

    menu_stud = Menu(root)
    root.config(menu=menu_stud)
    submenu_admin = Menu(menu_stud, tearoff=0)
    menu_stud.add_cascade(label='Просмотр занятий', menu=submenu_admin)
    submenu_admin.add_command(label='Просмотр теоретический занятий', command=viewing_dates_theory)
    submenu_admin.add_command(label='Просмотр практических занятий', command=lambda: viewing_dates_practice(selected_student_id))
    menu_stud.add_command(label='Внести дополнительные данные', command=lambda: additional_data(selected_student_id))


def viewing_dates_theory():
    # Создание окна для отображения
    dates_theory = Toplevel()
    dates_theory.title('Даты теоретических занятий')

    # Настройка Treeview
    tree = ttk.Treeview(dates_theory, columns=('Дата_занятия', 'Тема_занятия'), show='headings')
    tree.heading('Дата_занятия', text='Дата занятия')
    tree.heading('Тема_занятия', text='Тема занятия')
    tree.pack()

    # Подключение к базе данных и выборка данных
    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("SELECT * FROM theoru_class")
        for row in c.fetchall():
            tree.insert('', 'end', values=row)


def viewing_dates_practice(selected_student_id):
    dates_practice = Toplevel()
    dates_practice.title('Даты практических занятий')

    # Create the tree view widget
    tree = ttk.Treeview(dates_practice, columns=('Фамилия', 'Дата', 'Количество_часов'), show='headings')
    tree.heading('Фамилия', text='Фамилия')
    tree.heading('Дата', text='Дата')
    tree.heading('Количество_часов', text='Количество часов')

    with sq.connect("databaz.db") as db:
        c = db.cursor()
        c.execute("""
            SELECT p.Фамилия, sh.Дата_занятия, sh.Количество_часов
            FROM student_hour sh
            JOIN people p ON sh.ID = p.ID
            WHERE sh.ID = ?
        """, (selected_student_id,))
        rows = c.fetchall()
    for row in rows:
        tree.insert('', 'end', values=row)
    tree.pack()


def additional_data(selected_student_id):
    def save_data():
        number = num_entry.get()
        adres = adres_entry.get()

        # Получение фамилии и имени из таблицы people
        with sq.connect("databaz.db") as db:
            c = db.cursor()
            c.execute("SELECT Фамилия, Имя FROM people WHERE ID = ?", (selected_student_id,))
            result = c.fetchone()
            if result:
                surname, name = result
                # Вставка данных в таблицу student_add
                c.execute("INSERT INTO student_add (Фаммилия, Имя, Номер_телефона, Адрес) VALUES (?, ?, ?, ?)",
                          (surname, name, number, adres))
                db.commit()
                print("Данные успешно добавлены.")
                mb.showinfo("Успех", "Данные успешно добавлены")
            else:
                print("Студент не найден.")
                mb.showerror("Ошибка", "Студент не найден.")

    add_data = Toplevel()
    add_data.title("Внесение дополнительных данных")

    Label(add_data, text="Введите телефон").pack()
    num_entry = Entry(add_data)
    num_entry.pack()

    Label(add_data, text="Введите адрес").pack()
    adres_entry = Entry(add_data)
    adres_entry.pack()

    Button(add_data, text="Добавить", command=save_data).pack()


def logout(root):
    global current_user
    current_user = None
    login_screan(root)


def clear_screen(root):
    for widget in root.winfo_children():
        widget.destroy()


if __name__ == "__main__":
    root = Tk()
    root.title('Авторизация')
    root.geometry('400x300')
    root.iconbitmap('Автошколакамикадзе.ico')
    login_screan(root)

    root.mainloop()
    #ПАМАГИТЕЕЕЕЕ СПАСИТЕЕЕЕ СООООООООООООООООООООООООООООООС
